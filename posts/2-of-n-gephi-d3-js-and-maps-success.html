<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2015-11-11">

<title>Ryan M Horne - 2 of N: Gephi, D3.js, and maps: Success!</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Ryan M Horne</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv.html"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../digital-portfolio.html"> 
<span class="menu-text">Digital Portfolio</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/rmhorne"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://orcid.org/0000-0002-5009-3116"> 
<span class="menu-text">https://orcid.org/0000-0002-5009-3116</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://hcommons.social/web/@rmhorne"> <i class="bi bi-mastodon" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/RyanMHorne"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2 of N: Gephi, D3.js, and maps: Success!</h1>
  <div class="quarto-categories">
    <div class="quarto-category">code</div>
    <div class="quarto-category">maps</div>
    <div class="quarto-category">social-networks</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 11, 2015</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>[caption id=“attachment_251” align=“alignright” width=“300”]<a href="http://awmc.unc.edu/awmc/applications/experiments/snagg/"><img src="https://ryanmatthewhorne.files.wordpress.com/2015/11/gephileafletd3js.png?w=300" class="img-fluid" alt="gephileafletd3js"></a> A working, geographically accurate map using <a href="https://gephi.github.io/">Gephi</a>, <a href="http://d3js.org/">D3.js</a>, and <a href="http://leafletjs.com/">Leaflet</a>. NOTE: Link subject to change.[/caption]</p>
<p>In my <a href="https://ryanmatthewhorne.wordpress.com/2015/11/07/1-of-n-gephi-d3-js-and-maps/">previous post</a> I outlined how I used <a href="http://d3js.org/">D3.js</a> to display a “raw” JSON output from <a href="https://gephi.github.io/">Gephi</a>. After some hacking around, I am now able to display my Gephi data on an interactive <a href="http://leafletjs.com/">leaflet</a> map!</p>
<p>This is a departure from <a href="http://bost.ocks.org/mike/leaflet/">other</a> <a href="http://bost.ocks.org/mike/leaflet/">work</a> <a href="http://www.digital-geography.com/d3-geodata-basics-a-map-overlay-can-have-many-faces/#.VkNCxK6rRp8">on</a> the subject for a few reasons:</p>
<ol type="1">
<li>Not all of my data has geographic information - indeed in many cases a specific longitude / latitude combination is inappropriate and would lend a false sense of permanence to anyone looking at the map. In my case I have names of Greek garrison commanders which have some relation to a place, but it is unclear in some instances&nbsp;if they are actually at a specific place, have dominion over the location, or are mentioned in an inscription for some other reason. Therefore, I need to locate data that has a fuzzy relation&nbsp;to a location (ancient people who may originate, reside, work, and be mentioned in different and / or unknown locations) and locations that may themselves have fuzzy or unknown geography.&nbsp;This is a problem for just about every ancient to pre-modern project, as we do not have a wealth of location information, or even a clear idea of where some people are at any particular moment.</li>
<li>I want to show how social networks form around specific geographic points which are known, and have those social networks remain “reactive” on zooms, changing map states, etc. This can be expanded to encompass epistolary networks, knowledge maps, etc - basically anything that links people together who may not be locatable themselves.</li>
<li>Gephi does not output in GeoJSON, and the remaining export options that are geographically oriented require that *all* nodes have geographic information. As this is not my case (see above), the standard export options will not work for me. Also, as part of my work on <a href="https://bigancientmediterranean.wordpress.com/">BAM</a>, I want to create a framework that is as “plug and play” as possible, so that we can simply take Gephi files and drop them into the system to make new modules. Therefore this work has to be reproducible with a minimum of tweaking.</li>
</ol>
<p>So, let us get to the code!</p>
<p>First things first: You need to make your html, bring in your javascript,and style some elements. I put the css in the file for testing - it will be split off later.</p>
<p>[code language=“javascript”]</p>
<p>&lt;!DOCTYPE html&gt;</p>
<p>&lt;head&gt; &lt;meta name=‘viewport’ content=‘width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no’ /&gt; &lt;!– Mapbox includes below –&gt; &lt;script src=‘https://api.mapbox.com/mapbox.js/v2.2.2/mapbox.js’&gt;&lt;/script&gt; &lt;link href=‘https://api.mapbox.com/mapbox.js/v2.2.2/mapbox.css’ rel=‘stylesheet’ /&gt; &lt;script src=“https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js”&gt;&lt;/script&gt; &lt;script src=“http://d3js.org/d3.v3.js”&gt;&lt;/script&gt; &lt;/head&gt; &lt;meta charset=“utf-8”&gt; &lt;!– Will split off css when done with testing –&gt;</p>
<p>&lt;style&gt; .node circle { stroke: grey; stroke-width: 10px; }</p>
<p>.link { stroke: black; stroke-width: 1px; opacity: .2; }</p>
<p>.label { font-family: Arial; font-size: 12px; }</p>
<p>#map { height: 98vh; }</p>
<p>#attributepane { display: block; display: none; position: absolute; height: auto; bottom: 20%; top: 20%; right: 0; width: 240px; background-color: #fff; margin: 0; background-color: rgba(255, 255, 255, 0.8); border-left: 1px solid #ccc; padding: 18px 18px 18px 18px; z-index: 8998; overflow: scroll; } &lt;/style&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;div id=‘attributepane’&gt;&lt;/div&gt;</p>
<p>&lt;div id=‘map’&gt; &lt;/div&gt;</p>
<p>[/code]</p>
<p>Next,&nbsp;make a map.</p>
<p>[code language=“javascript”] &lt;script&gt; var map = L.mapbox.map(‘map’, ‘yourmap’, { accessToken: ‘yourtoken’ });</p>
<p>//set the initial view. This is pretty standard for most of the ancient med. projects map.setView([40.58058, 36.29883], 4);</p>
<p>[/code]</p>
<p>Pretty basic so far. Next we follow some of the examples that are already in the wild to initiate D3 goodness:</p>
<p>[code language=“javascript”]</p>
<p>var force = d3.layout.force() .charge(-120) .linkDistance(30);</p>
<p>/* Initialize the SVG layer */ map._initPathRoot();</p>
<p>/* We simply pick up the SVG from the map object */ var svg = d3.select(“#map”).select(“svg”), g = svg.append(“g”);</p>
<p>[/code]</p>
<p>Next, we bring in our json file from Gephi. Again, this is pretty standard:</p>
<p>[code language=“javascript”]</p>
<p>d3.json(“graph.json”, function(error, json) {</p>
<p>if (error) throw error;</p>
<p>[/code]</p>
<p>Now we get into the actual modifications to make the json, D3, and leaflet all talk to each other. The first thing to do is to modify the colors (from <a href="http://stackoverflow.com/questions/13070054/convert-rgb-strings-to-hex-in-javascript">http://stackoverflow.com/questions/13070054/convert-rgb-strings-to-hex-in-javascript</a>) so that D3 displays what we have in Gephi:</p>
<p>[code language=“javascript”]</p>
<p>//fix up the data so it is what we want for d3 json.nodes.forEach(function(d) { //convert the rgb colors to hex for d3 var a = d.color.split(“(”)[1].split(“)”)[0]; a = a.split(“,”);</p>
<p>var b = a.map(function(x) { //For each array element x = parseInt(x).toString(16); //Convert to a base16 string return (x.length == 1) ? “0” + x : x; //Add zero if we get only one character }) b = “#” + b.join(““); d.color = b;</p>
<p>[/code]</p>
<p>Next, we need to put in “dummy” coordinates for locations that do not have geography. This is messy and could probably be removed with some more efficient coding later. For the nodes that do have geography, the map.latLngToLayerPoint will translate the values into map units, which places them where they need to go. These are simply lat lon attributes in the Gephi file. I also set nodes that are fixed / not fixed, based on the presence of lat/lon data.</p>
<p>[code language=“javascript”]</p>
<p>if (!(“lng” in d.attributes) == true) { //if there is no geography, then allow the node to float around d.LatLng = new L.LatLng(0, 0); d.fixed = false; } else //there is geography, so place the node where it goes { d.LatLng = new L.LatLng(d.attributes.lat, d.attributes.lng); d.fixed = true; d.x = map.latLngToLayerPoint(d.LatLng).x; d.y = map.latLngToLayerPoint(d.LatLng).y; } })</p>
<p>[/code]</p>
<p>Now to setup the links. As we are keyed on attributes and not an index value, we need to <a href="http://stackoverflow.com/questions/23986466/d3-force-layout-linking-nodes-by-name-instead-of-index.">follow this fix</a>:</p>
<p>[code language=“javascript”]</p>
<p>var edges = []; json.edges.forEach(function(e) { var sourceNode = json.nodes.filter(function(n) { return n.id === e.source; })[0], targetNode = json.nodes.filter(function(n) { return n.id === e.target; })[0];</p>
<p>edges.push({ source: sourceNode, target: targetNode, value: e.Value }); });</p>
<p>var link = svg.selectAll(“.link”) .data(edges) .enter().append(“line”) .attr(“class”, “link”);</p>
<p>[/code]</p>
<p>Now to setup the nodes. I wanted to do a popup on a mouseclick event, but for some reason this is not firing (mousedown and mouseover do work, however). The following code builds the nodes, with radii, fill, and other information pulled from the JSON file. It also toggles a div that is populated with attribute information from the JSON. There is still some work to do at this part: the .css needs to be cleaned up, images need to be resized, and the attribute information for the nodes should be a configurable option when importing the JSON.</p>
<p>[code language=“javascript”]</p>
<p>var node = svg.selectAll(“.node”) .data(json.nodes) .enter().append(“circle”) //display nodes and information when a node is clicked on //for some reason the click event is not registering, but mousedown and mouseover are. .on(“mouseover”, function(d) {</p>
<p>//put in blank values if there are no attributes var titleForBox, imageForBox, descriptionForBox = ’‘; titleForBox =’ &lt;h1&gt;’ + d.label + ’&lt;/h1&gt;</p>
<p>’;</p>
<p>if (typeof d.attributes.Description != “undefined”) { descriptionForBox = d.attributes.Description; } else { descriptionForBox = ’’; }</p>
<p>if (typeof d.attributes.image != “undefined”) { imageForBox = ‘&lt;img src=“’ + d.attributes.image + ‘” align=“left”&gt;’; } else { imageForBox = ’’; }</p>
<p>var htmlForBox = imageForBox + ’ ’ + titleForBox + descriptionForBox; document.getElementById(“attributepane”).innerHTML = htmlForBox; toggle_visibility(‘attributepane’); }) .style(“stroke”, “black”) .style(“opacity”, .6) .attr(“r”, function(d) { return d.size * 2; }) .style(“fill”, function(d) { return d.color; }) .call(force.drag);</p>
<p>[/code]</p>
<p>Now for the transformations when the map state changes. The idea is to keep the fixed nodes in the correct place, but to redraw the “floating” nodes when the map is zoomed in and out. The nodes that need to be transformed are dealt with first, then the links are rebuilt with the new (or fixed) x / y data.</p>
<p>[code language=“javascript”]</p>
<p>//for when the map changes viewpoint map.on(“viewreset”, update); update();</p>
<p>function update() {</p>
<p>node.attr(“transform”, function(d) { if (d.fixed == true) { d.x = map.latLngToLayerPoint(d.LatLng).x; d.y = map.latLngToLayerPoint(d.LatLng).y; return “translate(” + map.latLngToLayerPoint(d.LatLng).x + “,” + map.latLngToLayerPoint(d.LatLng).y + “)”; } } );</p>
<p>link.attr(“x1”, function(d) { return d.source.x; }) .attr(“y1”, function(d) { return d.source.y; }) .attr(“x2”, function(d) { return d.target.x; }) .attr(“y2”, function(d) { return d.target.y; });</p>
<p>node.attr(“cx”, function(d) { if (d.fixed == false) { return d.x; } }) .attr(“cy”, function(d) { if (d.fixed == false) { return d.y; } })</p>
<p>//this kickstarts the simulation, so the nodes will realign to a zoomed state force.start(); }</p>
<p>[/code]</p>
<p>Next, time to start the simulation for the first time and close out the d3 json block:</p>
<p>[code language=“javascript”]</p>
<p>force .links(edges) .nodes(json.nodes) .start(); force.on(“tick”, update);</p>
<p>}); //end</p>
<p>[/code]</p>
<p>Finally, time to put a function in to toggle the visibility of the div (<a href="http://blog.movalog.com/a/javascript-toggle-visibility/">from here</a>) and close out our file:</p>
<p>[code language=“javascript”]</p>
<p>function toggle_visibility(id) { var e = document.getElementById(id); if (e.style.display == ‘block’) e.style.display = ‘none’; else e.style.display = ‘block’; } &lt;/script&gt; &lt;/body&gt;</p>
<p>[/code]</p>
<p>There you have it- a nice, interactive map with a mix of geographic information and social networks. While I am pleased with the result, there are still some things to fix / address:</p>
<ol type="1">
<li>The click even not working. This is a real puzzler.</li>
<li>Tweaking the distances of the simulation - I do not want nodes to be placed half a world away from their connections. This may have to be map zoom level dependent.</li>
<li>Style the links according to Gephi and provide popups where applicable. This should be easy enough to do, but simply hasn’t been done in this code.</li>
<li>Tweak the visibility of the connections and nodes. While retaining an&nbsp;option to show the entire network at once, my idea is to have a map that starts out with JUST the locations, and then makes the nodes that are connected to that location visible when you click&nbsp;on it (which would also apply to the unlocated nodes - i.e.&nbsp;you see what they are connected to when you click on them).</li>
<li>Connected to the above point, the implementation of a slider to show nodes in a particular timeframe. As my data spans a period from the 600s BCE to the 200s CE, this would provide a better snapshot of a particular network at a particular time.</li>
<li>Implement a URI based system - you will be able to go to address/someEntityName and that entity will be selected with its information pane and connected neighbors displayed. This will result in an RDF file that will be sent to the <a href="http://pelagios-project.blogspot.com/">Pelagios Project</a>.</li>
<li>Fix up the .css for the information pane.</li>
</ol>
<p>I will detail further steps in a later post.</p>



<p><br><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>